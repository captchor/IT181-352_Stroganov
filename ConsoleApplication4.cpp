#include "stdafx.h"
#include <iostream>
// for - оператор цикла с отсчётом
//
//for(целочисл_переменная; условие_продолжения; повторяемое_действие)
//{
// действия, повторяемые, пока (условие_продолжения == true)
//}

// while(условие) - действия выполняются до тех пор, пока условие == true
//{ // условие проверяется ПЕРЕД каждым заходом в цикл

//}


// while - цикл с пред-условием, т.е. сначала проверяется условие, затем выполняется действие

// do-while - цикл с постусловием
// do
//{

//}

continue; // переход на следующую ИТЕРАЦИЮ

break; // ВЫХОД из цикла

for (;;)
{
	if (k >= 10)
	{
		break;
	}
	std::cout << "arr[k] = " << arr[k] << std::endl;
	k++;
}

// также возможен такой вариант
for (int i = 0, j = 5; // через "," можно перечислить сколько угодно операторов
	i + j < 10, j < 10; // ???
	i++, j = j + 2, std::cout << "i=" << i << '\t' << "j = " << j << std::endl) // через "," можно перечислить сколько угодно операторов
{
	// действия, повторяемые, пока i + j < 10
}

// тернарный оператор (сокращённая запись)
// (лог_выр) ? (операторы если true) : (операторы если false)
// переписываем первый пример if

(d == 0) ?
(std::cout << "d == 0" << std::endl) :
	(
	(d > 0) ?
		(std::cout << "d > 0" << std::endl) :
		(std::cout << "d < 0" << std::endl)
		);
//несмотря на то, что программист вручную не прописывает вызов конструктора и диструктора, они все равно срабатывают:
//компилятор при анализе текста отслеживает когда объект появяется и исчезает, и автоматически, неявно для программиста
//подставляет вызов конструктора и диструктора в коде
//конструктор\диструктор класса 
//конструктор- функция с названием, совпадающим с названием класса
function_add_ 
class vehicle
{
	
public:
	vehicle(/*могут быть входные параметры*/)//конструктор
	{

			std::cout << "constructor of vehicle" << std::endl;
		return;
	}
	~vehicle(/*не может быть входных параметров*/)//деструктор
	{
		return;
	}
}
//конструктор не может возвращать параметры, но может иметь вхожные параметры, диструктор не может иметь ни входных, ни выходных
//конструктором и диструктором автоматически назначается функция, имеющая тоже имя, что и класс
//диструктор с ~
//конструктор обязательно должен быть публичным(public)
//объявление класса остаётся объявление (заголовок) метода
//тело метода переносится наружу вместе с копией заголовка
//к заголовку реализации добавляется имя класса с двумя двоеточиями ("имя_класса::")
